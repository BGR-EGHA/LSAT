import docx
import logging
import math
import os
from PyQt5.QtCore import QObject
import time
from core.libs.GDAL_Libs.Layers import Raster
from core.libs.Reporting.shared_report import shared_report


class ahp_report(QObject):
    """
    Generates a Word document with information about the AHP calculation generated by ahp_calc.
    """

    def __init__(self, outputname: str, project_path: str, result: object):
        """
        outputname: File name the resulting doc gets saved as.
        project_path: Path to the current project
        result: Handle of the npz file.
        """
        super().__init__()
        # We open and prepare the template for editing
        doc = shared_report.opentemplate()
        # Initial paragraph with basic project and calculation information
        doc = self.writebasics(
            doc,
            project_path,
            result["scale"],
            result["prioritymethod"],
            result["rastervaluescomp"],
            result["coefficientpriorities"],
            result["uniquePerRaster"])
        # A paragraph with the raster comparison
        doc = self.writeraster(doc, result["rastercomp"])
        # An additional paragraph for each raster with its information
        doc = self.writerasterspecific(
            doc,
            result["uniquePerRaster"],
            result["rastervaluescomp"],
            result["transformedrastervaluescomp"],
            result["rastervaluepriorities"],
            result["lambda_max_values"],
            result["coefficientpriorities"],
            result["CI"],
            result["RI"],
            result["CR_Saaty"],
            result["CR_AlonsoLamata"])
        # Finally we save the document.
        shared_report.savedoc(outputname, project_path, doc, "AHP")
        logging.info(
            self.tr("Report saved under {}").format(
                os.path.join(
                    project_path,
                    "results",
                    "AHP",
                    "reports",
                    outputname +
                    ".docx")))

    def writebasics(
            self,
            doc,
            project_path,
            scale,
            prioritymethod,
            rastervaluescomp,
            coefficientpriorities,
            uniquePerRaster):
        """
        Writes the initial paragraph of the report. Contains:
        a basic table with type of analysis, Date and time, projectname, method to derive priority
        vector, scale of transformation AND
        a table with the coefficient priority for each value of every raster
        """
        doc.add_heading(self.tr("Analysis Report"))
        doc.add_paragraph(self.tr(
            "This is an automatically generated LSAT analytical hierarchy process (AHP) analysis report."))
        doc.add_heading(self.tr("General Information"), level=2)
        self._add_basictable(doc, project_path, prioritymethod, scale, rastervaluescomp)
        doc.add_heading(self.tr("Coefficient Priorities"), level=3)
        self._add_coefficienttable(doc, coefficientpriorities, uniquePerRaster)
        return doc

    def _add_basictable(self, doc, project_path, prioritymethod, scale, rastervaluescomp):
        """
        Gets called by writebasics. Generates the table with basic info.
        """
        basicstable = doc.add_table(5, 2, style='Light Shading Accent 1')
        basicstable.cell(0, 0).text = self.tr("Project name")
        # Name of the lowest folder is the project name
        # this should be \ (windows os.sep) but isn't...
        basicstable.cell(0, 1).text = project_path.split("/")[-1]
        basicstable.cell(1, 0).text = self.tr("Time and date")
        # Returns the current date and time exact to the minute
        basicstable.cell(1, 1).text = time.strftime("%Y-%m-%d %H:%M", time.localtime())
        basicstable.cell(2, 0).text = self.tr("Method to derive priorities")
        # We only know the combobox id and need to look up which method belongs to it
        basicstable.cell(2, 1).text = self._get_methodname(prioritymethod)
        basicstable.cell(3, 0).text = self.tr("Scale for transformation")
        # We only know the combobox id and need to look up which scale belongs to it
        basicstable.cell(3, 1).text = self._get_scalename(scale)
        basicstable.cell(4, 0).text = self.tr("Amount of rasters")
        # The amount of elments in rastervaluescomp is the amount of rasters
        basicstable.cell(4, 1).text = str(len(rastervaluescomp))

    def _get_methodname(self, prioritymethod):
        """
        Returns a string with the name of the used prioritymethod based on the index from the
        combobox.
        """
        if prioritymethod == 0:
            get_prioritymethod = "Mean of the row"
        elif prioritymethod == 1:
            get_prioritymethod = "Row Geometric mean"
        elif prioritymethod == 2:
            get_prioritymethod = "Eigenvalue"
        return get_prioritymethod

    def _get_scalename(self, scale):
        """
        Returns a string with the name used for transformation.
        """
        if scale == 0:
            get_c = "Linear"
        elif scale == 1:
            get_c = "Logarithmic"
        elif scale == 2:
            get_c = "Root Squar"
        elif scale == 3:
            get_c = "Inverse linear"
        elif scale == 4:
            get_c = "Balanced"
        elif scale == 5:
            get_c = "Power"
        elif scale == 6:
            get_c = "Geometric"
        elif scale == 7:
            get_c = "Asymptotical"
        return get_c

    def _add_coefficienttable(self, doc, coefficientpriorities, uniquePerRaster):
        """
        Adds a table with the coefficient priorities that form the final LSI.
        """
        # Amount of rows in the table is the total amount of values from all rasters +1 (Header)
        row = 0
        values = []
        for uniqueValues in uniquePerRaster:
            row += len(uniqueValues[0])
            values.append(uniqueValues[0])
        rastertable = doc.add_table(row + 1, 3, style='Medium Shading 1 Accent 1')
        rastertable.cell(0, 0).text = self.tr("Raster")
        rastertable.cell(0, 1).text = self.tr("Value")
        rastertable.cell(0, 2).text = self.tr("Coefficient Priority")
        # In the first column we write the file name of the raster left of its first value.
        # p lets us keep track through both for loops where we are in the table
        p = 0
        for i, raster in enumerate(uniquePerRaster):
            rastertable.cell(p + 1, 0).text = os.path.split(raster[1])[-1]
            for j, uniquevalue in enumerate(raster[0]):  # unique value list
                rastertable.cell(p + 1, 1).text = str(uniquevalue)
                rastertable.cell(p + 1, 2).text = str(round(coefficientpriorities[i][0][j], 3))
                p += 1
        return doc

    def writeraster(self, doc, rastercomp):
        """
        Creates a new paragraph containing a table with the pairwise raster comparison.
        """
        doc.add_heading(self.tr("Pairwise raster comparison"), level=2)
        self._add_rastercomptable(doc, rastercomp)
        return doc

    def _add_rastercomptable(self, doc, rastercomp):
        """
        Gets called by writeraster.
        Adds a table containing the pairwise raster comparison.
        """
        # to get a square shaped array we calculate the Root of the size of the array
        square_rastercomp = rastercomp[0].reshape(int(math.sqrt(rastercomp[0].size)), -1)
        # We create a list of raster file names to use for the table.
        # We ditch the full path for better visibility.
        rastertable = doc.add_table(len(rastercomp[1]) + 1, len(rastercomp[1]) + 1,
                                    style='Medium Shading 2 Accent 1')
        # Writes the raster file names in the first column and row
        for n in range(len(rastercomp[1])):
            rastertable.cell(0, n + 1).text = os.path.split(rastercomp[1][n])[-1]
            rastertable.cell(n + 1, 0).text = os.path.split(rastercomp[1][n])[-1]
        # Writes paired matrix into the table
        for row in range(len(rastertable.rows)):
            for col in range(len(rastertable.columns)):
                # We skip the first row and column because this is where we wrote the raster names
                if row > 0 and col > 0:
                    rastertable.cell(row, col).text = str(
                        round(square_rastercomp[row - 1][col - 1], 3))
        return doc

    def writerasterspecific(
            self,
            doc,
            uniquePerRaster,
            rastervaluescomp,
            transformedrastervaluescomp,
            rastervaluepriorities,
            lambda_max_values,
            coefficientpriorities,
            CI,
            RI,
            CR_Saaty,
            CR_AlonsoLamata):
        """
        Adds raster specific information to the document in the form of two tables.
        """
        # We need a new paragraph for each raster
        # rastervaluescomp = [[np.array with priorities of raster values, path to raster],....]
        for i, raster in enumerate(rastervaluescomp):
            # filename
            rastername = os.path.split(raster[1])[-1]
            doc.add_heading(self.tr("{}").format(rastername), level=2)
            # We add a table with information that correspond to the raster
            self._add_rastertable1value(
                doc,
                i,
                raster,
                lambda_max_values,
                CI,
                RI,
                CR_Saaty,
                CR_AlonsoLamata)
            # We add a table with information that cover the rasters values
            doc.add_heading(self.tr("Raster value priorities"), level=3)
            self._add_rastertablenvalues(
                doc,
                i,
                uniquePerRaster,
                rastervaluepriorities,
                coefficientpriorities)
            # We add a table for the comparison and the transformed comparison
            doc.add_heading(self.tr("Pairwise raster value comparison"), level=3)
            self._add_valuescomparisontable(doc, i, uniquePerRaster, rastervaluescomp)
            doc.add_heading(self.tr("Pairwise transformed raster value comparison"), level=3)
            self._add_transformedvaluescomparisontable(
                doc, i, uniquePerRaster, transformedrastervaluescomp)
        return doc

    def _add_rastertable1value(
            self,
            doc,
            i,
            raster,
            lambda_max_values,
            CI,
            RI,
            CR_Saaty,
            CR_AlonsoLamata):
        """
        Gets called writerasterspecific.
        Generates a table for each raster with values that only exist once per raster.
        """
        rastertable = doc.add_table(7, 2, style='Light Shading Accent 1')
        # If we have a long filename we want it over multiple lines
        rastertable.autofit = False
        rastertable.allow_autofit = False
        rastertable.cell(0, 0).text = self.tr("Path to raster")
        rastertable.cell(0, 1).text = raster[1]
        rastertable.cell(1, 0).text = self.tr("Î»_max")
        rastertable.cell(1, 1).text = str(round(lambda_max_values[i][0], 3))
        rastertable.cell(2, 0).text = self.tr("n")
        rastertable.cell(2, 1).text = str(raster[0].shape[0])
        rastertable.cell(3, 0).text = self.tr("Consistency Index")
        rastertable.cell(3, 1).text = str(round(float(CI[i][0]), 3))
        rastertable.cell(4, 0).text = self.tr("Random Consistency Index")
        rastertable.cell(4, 1).text = str(RI[i][0])
        rastertable.cell(5, 0).text = self.tr("Consistency Ratio (Saaty)")
        rastertable.cell(5, 1).text = str(round(float(CR_Saaty[i][0]), 3))
        rastertable.cell(6, 0).text = self.tr("Consistency Ratio (Alonso & Lamata)")
        rastertable.cell(6, 1).text = str(round(float(CR_AlonsoLamata[i][0]), 3))
        return doc

    def _add_rastertablenvalues(
            self,
            doc,
            i,
            uniquePerRaster,
            rastervaluepriorities,
            coefficientpriorities):
        """
        Gets called by writerasterspecific.
        Generates a table with inforation that is different for each raster value n.
        """
        uniquevalues = uniquePerRaster[i][0]
        uniquevaluescount = len(uniquePerRaster[i][0])
        rastertable = doc.add_table(uniquevaluescount + 1, 3, style='Medium Shading 1 Accent 1')
        rastertable.cell(0, 0).text = self.tr("Values")
        rastertable.cell(0, 1).text = self.tr("Priority vector")
        rastertable.cell(0, 2).text = self.tr("Coefficient Priorities")
        for n in range(uniquevaluescount):
            # Raster value
            rastertable.cell(n + 1, 0).text = str(uniquevalues[n])
            # Raster value priority
            rastertable.cell(n + 1, 1).text = str(round(rastervaluepriorities[i][0][n], 3))
            # Coefficient priority
            rastertable.cell(n + 1, 2).text = str(round(coefficientpriorities[i][0][n], 3))
        return doc

    def _add_valuescomparisontable(self, doc, i, uniquePerRaster, rastervaluescomp):
        """
        Gets called by writerasterspecific.
        Writes the paired comparison matrix into a new table.
        """
        uniquevaluesstr = [str(x) for x in uniquePerRaster[i][0]]
        uniquevaluescount = len(uniquePerRaster[i][0])
        valuestable = doc.add_table(uniquevaluescount + 1, uniquevaluescount + 1,
                                    style='Medium Shading 2 Accent 1')
        # Writes the values in the first column and row
        for n in range(uniquevaluescount):
            valuestable.cell(0, n + 1).text = uniquevaluesstr[n]
            valuestable.cell(n + 1, 0).text = uniquevaluesstr[n]
        # Writes paired matrix into the table
        for row in range(len(valuestable.rows)):
            for col in range(len(valuestable.columns)):
                # We skip the first row and column because this is where we wrote the values
                if row > 0 and col > 0:
                    valuestable.cell(row, col).text = str(
                        round(rastervaluescomp[i][0][row - 1][col - 1], 3))
        return doc

    def _add_transformedvaluescomparisontable(
            self, doc, i, uniquePerRaster, transformedrastervaluescomp):
        """
        Gets called by writerasterspecific.
        Writes the transformed paired comparison matrix into a new table.
        """
        uniquevaluesstr = [str(x) for x in uniquePerRaster[i][0]]
        uniquevaluescount = len(uniquePerRaster[i][0])
        valuestable = doc.add_table(uniquevaluescount + 1, uniquevaluescount + 1,
                                    style='Medium Shading 2 Accent 1')
        # Writes the values in the first column and row
        for n in range(uniquevaluescount):
            valuestable.cell(0, n + 1).text = uniquevaluesstr[n]
            valuestable.cell(n + 1, 0).text = uniquevaluesstr[n]
        # Writes paired matrix into the table
        for row in range(len(valuestable.rows)):
            for col in range(len(valuestable.columns)):
                # We skip the first row and column because this is where we wrote the values
                if row > 0 and col > 0:
                    valuestable.cell(row, col).text = str(
                        round(transformedrastervaluescomp[i][0][row - 1][col - 1], 3))
        return doc
